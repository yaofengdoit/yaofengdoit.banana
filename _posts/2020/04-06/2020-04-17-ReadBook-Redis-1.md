---
layout: post
title: 读书笔记之《Redis开发与运维》
category: 读书笔记
tags: [读书笔记]
no-post-nav: true
---

一、前言

&ensp;&ensp;&ensp;&ensp;读书笔记系列主要记录自己看的书籍中的知识点，算是一个归纳整理吧。Redis在我们的日常开发中可以说是很常用了，《Redis开发与运维》
这本书讲解了Redis开发和运维的方方面面，很系统、全面，关键是实用。特来撸撸它，记录一番。全书分为14章，下面将记录个人认为每章中重要的知识点。

二、Redis初识

&ensp;&ensp;&ensp;&ensp;Redis是一种基于键值对（key-value）的NoSQL数据库，Redis中的值可以是由string(字符串)、hash(哈希)、list(列表)、set(集合)、zset(有序集合)、
Bitmaps(位图)、HyperLogLog、GEO(地理信息定位)等多种数据结构和算法构成，可以满足很多的应用场景。因为Redis会将所有数据都放在内存里，所以它的读写
性能非常好。Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样发生断电或者机器故障，内存中的数据就不会丢失。当然Redis还提供了其他很多附加功能。

1、Redis特性

(1)速度快

Redis的所有数据都是放在内存里的，这是速度快的最主要原因；<br/>
Redis是用C语言实现的，“距离”操作系统更近，执行速度相对会更快；<br/>
Redis采用单线程架构，预防了多线程可能产生的竞争问题；<br/>

(2)基于键值对的数据结构

Redis中的值不仅可以是字符串，还可以是具体的数据结构,方面在不同应用场景的开发。Redis主要提供五种数据结构：字符串、哈希、列表、集合、有序列表，并且在字符
串的基础上演变出来了位图(Bitmaps)和HyperLogLog俩种“数据结构”。Redis3.2版本加入了GEO(地理信息定位)的功能。

(3)丰富的功能

除了5种数据结构，还有其他额外的许多功能：

键过期功能，用来实现缓存；<br/>
发布订阅功能，用来实现消息系统；<br/>
Lua脚本功能，利用Lua脚本创造出新的Redis命令；<br/>
简单的事务功能，在一定程度上保证事务特性；<br/>
流水线(Pipeline)功能，客户端能将一批命令一次性传到Redis，减少网络开销。

(4)简单稳定

代码少，单线程，服务端、客户端处理简单，redis不依赖操作系统中的类库，自己实现了事件处理的相关功能。

(5)客户端语言多

redis提供了简单的TCP通信协议，很多编程语言可以很方便的接入到redis。

(6)持久化

redis提供了两种持久化方式：RDB和AOF。可以用这两种策略将内存的数据保存在硬盘中，保证了数据的可持久性。

(7)主从复制

redis提供了复制功能，实现了多个相同数据的redis副本，复制功能是分布式redis的基础。

(8)高可用和分布式

redis提供了高可用实现Redis Sentinel(哨兵)，能够保证redis节点的故障发现和故障自动转移。并且3.0版本提供了分布式实现Redis Cluster(集群),
这是redis真正的分布式实现，提供了高可用、读写和容量的扩展性。

2、Redis使用场景

缓存、排行榜系统、计数器应用（redis天然支持计数功能，且计数性能很好）、社交网络(粉丝、共同喜好、推送等，社交网站的访问量比较大，传统
的关系型数据库不太适合保存这种类型的数据，可用redis实现)、消息队列系统(消息队列具有业务解耦、非实时业务削峰等特性，redis可以满足一般
的消息队列功能，不过一般项目中还是使用专业的消息队列，更加强大)。

redis也有不适合它解决的问题场景，站在数据规模和数据冷热角度来分析的话：数据规模角度，数据可分为大规模数据和小规模数据，redis的数据是
放在内存里的，如果数据规模非常大，不适合使用redis存储；站在数据冷热角度，数据分为热数据和冷数据，热数据是指需要频繁操作的数据，如果将
冷数据放在redis中，浪费内存。

三、API的理解和使用

1、全局命令

(1)查看所有键：keys *    

(2)键总数：dbsize

注意：dbsize命令在计算总数时候不会遍历所有键，而是直接获取redis内部的键总数变量，时间复杂度O(1)；而keys命令会遍历所有键，时间复杂度O(n)，
如果redis保存了大量键时，线上环境禁止使用。

(3)检查键是否存在(键存在返回1，不存在返回0)：exists key

(4)删除键(返回的结果是成功删除的个数，删除一个不存在的键，返回0)：del key [key ...]   

注意：del key表示删除一个，del key1 key2 key3表示删除3个

(5)键过期：expire key seconds

注意：redis支持对键添加过期时间，超过过期时间后，会自动删除键；ttl key 命令会返回键的剩余过期时间，返回值>=0表示键的剩余过期时间，返回值
-1表示键没有设置过期时间，返回值-2表示键不存在。

(6)键的数据结构类型：type key

注意：如果键是字符串类型，返回string，如果键是列表类型，返回list，其他几种类似。如果键不存在，返回none。


2、数据结构的内部编码

每种数据结构都有自己底层的内部编码实现，而且是多种实现，redis会在合适的场景选择合适的内部编码。比如zset包含skiplist和ziplist两种内部编码。
这样设计的好处是：可以改进内部编码，而对外的数据结构和命令没有影响；多种内部编码实现可以在不同场景下发挥各自的优势，比如ziplist比较节省内存，
但是在列表元素比较多的情况下，性能会有所下降，这个时候redis会根据配置选项将列表类型的内部实现转换为linkedlist。

3、单线程架构

redis使用单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。一条命令从客户端达到服务端不会立刻执行，所有命令都会进入到一个队列中，
然后逐个被执行。不会有两条命令被同时执行。redis使用了I/O多路复用技术来解决I/O的问题。

redis使用单线程模式那么快的原因：纯内存访问，这个最重要；非阻塞I/O，redis使用epoll作为I/O多路复用技术的实现，并且redis加上自身的事件处理
模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间；单线程避免了线程切换和竞争产生的消耗。

注意：单线程会有一个问题，对于每个命令的执行时间是有要求的，如果执行时间过长，会造成其他命令的阻塞，对于redis来说是致命的，所以redis是面向
快速执行场景的数据库。

4、字符串

(1)设置值：set key value [ex seconds] [px milliseconds] [nx|xx]

注意：nx 键必须不存在，才可以设置成功，用于添加； xx 键必须存在，才可以设置成功，用于更新

(2)获取值：get key

批量设置值：mset key value [key value ...]

批量获取值：mget key [key ...]

注意：批量操作可以减少网络时间（n次网络时间+n次命令时间 ---> 1次网络时间+n次命令时间），但是每次批量操作所发送的命令不是无节制的，如果
数量过多可能造成redis阻塞或者网络阻塞。

(3)计数：incr key

incr命令用于对值做自增操作，如果值不是整数，返回错误；如果值是整数，返回自增后的结果；如果键不存在，按照值为0自增，返回结果1。

很多存储系统和编程语言内部使用CAS机制实现计数功能，会有一定的CPU开销，但redis中不存在这个问题，因为redis单线程架构，任何命令到了redis
服务端都要顺序执行。

(4)内部编码(redis会根据当前值的类型和长度决定使用哪种内部编码实现)

int(8个字节的长整形)  embstr(小于等于39个字节的字符串)  raw(大于39个字节的字符串)

(5)典型应用场景

缓存功能、计数、共享session、限速

5、哈希








