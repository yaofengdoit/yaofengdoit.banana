---
layout: post
title: 读书笔记之《Java并发编程的艺术》—— 三
category: 读书笔记
tags: [读书笔记]
no-post-nav: true
---

由于内容过多，分一个系列来写，这是第三篇。

六、Java并发容器和框架

1、ConcurrentHashMap的实现原理和使用

HashMap1.7、1.8在多线程并发情况下都会出现死循环。HashTable使用synchronized保证线程安全，在线程竞争激烈的情况下，效率很低。
ConcurrentHashMap1.7使用锁分段技术提升并发访问率。首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问
其中一个段数据的时候，其他段的数据也能被其他线程访问。ConcurrentHashMap 1.8里用Synchronized + CAS 代替了 Segment。

后面写专文介绍ConcurrentHashMap1.7、1.8和HashMap1.7、1.8版本的改动和原理吧，这里略过。


2、ConcurrentLinkedQueue

实现一个线程安全的队列有两种方式：使用阻塞算法、使用非阻塞算法。使用阻塞算法的队列可以用一个锁(入队和出队用同一把锁)或两个锁(入队和
出队用不同的锁)等方式实现。非阻塞的实现方式可以使用循环CAS来实现。

ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，采用先进先出的规则对节点进行排序。

HOPS的设计：并不是每次节点入队后都将tail节点更新为尾结点，也不是每次出队时都更新head节点，而是通过使用hops变量来控制并减少更新频率，
从而减少CAS的消耗。


3、Java中的阻塞队列

阻塞队列是一个支持两个附加操作的队列，支持阻塞的插入和移除方法。当队列满时，队列会阻塞插入元素的线程，直到队列不满；当队列为空时，获取元素
的线程会等待队列为非空。阻塞队列常用于生产者和消费者的场景，生产者是向队列添加元素的线程，消费者是从队列里取元素的线程。如果是无界阻塞队列，
队列不会出现满的情况。


4、Fork/Join框架

Fork/Join框架是一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。
