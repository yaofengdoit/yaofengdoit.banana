---
layout: post
title: 读书笔记之《Java并发编程的艺术》—— 二
category: 读书笔记
tags: [读书笔记]
no-post-nav: true
---

由于内容过多，分一个系列来写，这是第二篇。

三、Java内存模型

1、Java内存模型的基础

线程之间的通信机制有两种：共享内存和消息传递。

在Java里，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。局部变量、方法定义参数、异常处理参数不会在线程间共享。Java线程之间
的通信由Java内存模型(JMM)控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。线程之间的共享变量存储在主内存，每个线程都有一个私有的本地
内存(本地内存是JMM的一个抽象概念，并不真实存在)。JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证。

执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序(编译器优化的重排序，指令级并行的重排序，内存系统的重排序)。

为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为四类：LoadLoad、
StoreStore、LoadStore、StoreLoad。  StroeLoad是一个全能型的屏障，同时具有其他3个屏障的效果。

2、volatile的内存语义

volatile写的内存语义：<br/>
当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，
线程从主内存中读取共享变量。

在每个volatile写操作的前面插入一个StoreStore屏障，在每个volatile写操作的后面插入一个StoreLoad屏障，在每个volatile读操作的后面插入一个
LoadLoad屏障，在每个volatile读操作的后面插入一个LoadStore屏障。

volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥特性可以确保对整个临界区代码的执行具有原子性。

3、锁的内存语义

当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护
的临界区代码必须从主内存中读取共享变量。

4、final域的内存语义



