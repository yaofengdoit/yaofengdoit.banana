---
layout: post
title: JAVA基础知识总结
category: JAVA
tags: [JAVA]
---


1.变量类型
基本类型：基本类型的变量“持有”某个数值；引用类型：引用类型的变量“指向”某个对象。

2.基本数据类型
基本数据类型是CPU可以直接进行运算的类型。java中的基本数据类型有：
- 整数类型：byte short int long
- 浮点数类型：float double
- 字符类型：char
- 布尔类型：boolean

3.== 和 equals
- ==判断两个变量或者实例是不是指向同一个内存空间，equals判断两个变量或者实例所指向的内存空间的值是否相同
- ==是对内存地址进行比较，equals是对内容进行比较

4.break 和continue

break跳出当前循环，continue提前结束本次循环，继续执行下次循环。

#### 面向对象
面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。

5.类和实例
- class是一种对象模板，定义了如何创建实例，instance是对象实例，是根据class创建的实例。

6.参数传递
- 基本类型的参数传递，是调用方值的复制，双方各自的后续修改，互不影响；引用类型的参数传递，调用方的变量和接收方的变量，指向的是同一个对象，双方任意一方对此对象的修改都会影响到对方。

7.构造方法
- 构造方法用于初始化实例，如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法；如果定义了一个构造方法，那么，编译器就不再自动创建默认构造方法。注意：在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super()。

8.方法重载 方法重写
- 方法名相同，但各自的参数不同，称为方法重载（Overload）。方法重载的目的是，功能类似的方法使用同一名字，更容易记住，调用起来更简单。
- 在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为方法重写（Override）。

9.继承
- 继承是面向对象编程中非常强大的一种机制，可以复用代码。Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。子类无法访问父类的private字段或者private方法。子类不会继承任何父类的构造方法，子类默认的构造方法是编译器自动生成的，不是继承的。

10.多态
- 多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。

11.抽象类
- 使用abstract修饰的类就是抽象类。无法实例化一个抽象类。把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。抽象类本身被设计成只能用于被继承，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。
- 抽象类中可以定义非抽象方法。

12.接口
- 如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：interface。所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来。
- 一个类可以实现多个接口。
- 在接口中，可以定义default方法，实现类可以不用重写default方法。default方法的目的是，当需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要重写的地方去重写新增方法。

13.final关键字 
- final修饰的class可以阻止被继承；
- final修饰的方法可以阻止被重写；
- final修饰的属性必须在创建对象时初始化，随后不可修改。

14.static关键字
- static修饰的成员变量和方法，从属于类
- 普通变量和方法从属于对象
- 静态方法不能调用非静态成员，编译会报错
- 实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。推荐用类名来访问静态字段。

15.局部变量
- 在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。

16.String 
- 字符串在String内部是通过一个char[]数组表示的，
Java字符串的一个重要特点就是字符串不可变。

```
public class Main {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "hello";
        System.out.println(s1 == s2);
        System.out.println(s1.equals(s2));
    }
}
```
从比较结果看，两个都是true。这是因为Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的。
所以，这种==比较返回true纯属巧合。换一种写法，==比较就会失败：
```
public class Main {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "HELLO".toLowerCase();
        System.out.println(s1 == s2);
        System.out.println(s1.equals(s2));
    }
}
```
为什么一个true，一个false呢，原因是toLowerCase(),这个语句把s2指向了变为小写的字符串。

17.StringBuffer 和 StringBuilder
- StringBuilder，是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象。
- StringBuffer，是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer是安全的，但是同步会带来执行速度的下降。

18.自动装箱 自动拆箱
- 自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码；
- 装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException。

19.枚举
- Java使用enum定义枚举类型，它被编译器编译为final class Xxx extends Enum { … }；
- 枚举类是一种引用类型；
- 枚举类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较。
- 定义的enum类型总是继承自java.lang.Enum，且无法被继承；
- 只能定义出enum的实例，而无法通过new操作符创建enum的实例；

20.异常

Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception。Error表示严重的错误，程序对此一般无能为力，Exception则是运行时的错误，它可以被捕获并处理。

21.反射
- Java的反射是指程序在运行期可以拿到一个对象的所有信息。由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。这种通过Class实例获取class信息的方法称为反射（Reflection）。

22.注解
- 注解是一种用作标注的“元数据”，注解的本质就是一个继承了Annotation 接口的接口。

23.泛型
- 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。





